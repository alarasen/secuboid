/*
 *  Secuboid: Lands and Protection plugin for Minecraft server
 *  Copyright (C) 2014 Tabinol
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package app.secuboid.core.storage;

import app.secuboid.api.reflection.TableRegistered;
import app.secuboid.api.storage.rows.Row;
import app.secuboid.api.storage.tables.Table;
import app.secuboid.core.messages.Log;
import app.secuboid.core.reflection.PluginLoader;

import java.lang.reflect.InvocationTargetException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.*;
import java.util.logging.Level;

import static app.secuboid.core.config.Config.config;

public class StorageInit {

    private static final String CREATE_TABLE_SQL_FIELD = "CREATE_TABLE_SQL";

    static final String AUTOINCREMENT_TAG = "{{AUTOINCREMENT}}";
    static final String AUTOINCREMENT_MARIADB = "AUTO_INCREMENT";
    static final String AUTOINCREMENT_HSQLDB = "GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)";

    static final String TINYTEXT_TAG = "{{TINYTEXT}}";
    static final String TINYTEXT_MARIADB = "TINYTEXT";
    static final String TINYTEXT_HSQLDB = "LONGVARCHAR";

    static final String TEXT_TAG = "{{TEXT}}";
    static final String TEXT_MARIADB = "TEXT";
    static final String TEXT_HSQLDB = "LONGVARCHAR";

    static final String MEDIUMTEXT_TAG = "{{MEDIUMTEXT}}";
    static final String MEDIUMTEXT_MARIADB = "MEDIUMTEXT";
    static final String MEDIUMTEXT_HSQLDB = "LONGVARCHAR";

    static final String MARIADB_CREATE_SQL_SUFFIX = " CHARACTER SET 'utf8' COLLATE 'utf8_general_ci' ENGINE = InnoDB";

    private static final int MAX_LOOP_ATTEMPTS = 100;

    private final Map<Class<? extends Row>, Table<Row>> classRowToTable;

    StorageInit() {
        classRowToTable = new HashMap<>();
    }

    @SuppressWarnings("rawtypes")
    public void init(PluginLoader pluginLoader) {
        initConnectionManager();

        Map<Class<? extends Table>, TableRegistered> classToAnnotation = pluginLoader
                .getClassToAnnotation(TableRegistered.class, Table.class);
        Set<Class<? extends Table>> doneClasses = new HashSet<>();
        int i = 0;

        while (i < MAX_LOOP_ATTEMPTS && doneClasses.size() < classToAnnotation.size()) {
            i++;

            for (Map.Entry<Class<? extends Table>, TableRegistered> classToAnnotationEntry : classToAnnotation
                    .entrySet()) {
                Class<? extends Table> clazz = classToAnnotationEntry.getKey();

                if (!doneClasses.contains(clazz)) {
                    TableRegistered tableRegistered = classToAnnotationEntry.getValue();
                    boolean allMatch = Arrays.stream(tableRegistered.dependsOn()).allMatch(doneClasses::contains);

                    if (allMatch) {
                        createDatabase(clazz);
                        Class<? extends Row> classRow = tableRegistered.row();
                        addTableToFinder(classRow, clazz);
                        doneClasses.add(clazz);
                    }
                }
            }
        }

        if (doneClasses.size() < classToAnnotation.size()) {
            Log.log().log(Level.SEVERE, () -> String.format(
                    "Unable to finish the storage table initiation due to an infinite loop [doneClasses=%s, classToAnnotation=%s]",
                    doneClasses, classToAnnotation));
        }
    }

    Table<Row> getTableFromClassRow(Class<? extends Row> classRow) {
        return classRowToTable.get(classRow);
    }

    void initConnectionManager() {
        ConnectionManager.init();
    }

    @SuppressWarnings("rawtypes")
    void createDatabase(Class<? extends Table> clazz) {
        String createTableSQL;
        try {
            createTableSQL = (String) clazz.getField(CREATE_TABLE_SQL_FIELD).get(null);
        } catch (IllegalArgumentException | IllegalAccessException | NoSuchFieldException | SecurityException
                 | ClassCastException e) {
            Log.log().log(Level.SEVERE, e,
                    () -> String.format("Unable read the static field %s due to a programming error [clazz=%s]",
                            CREATE_TABLE_SQL_FIELD, clazz));
            return;
        }

        try (Connection connection = ConnectionManager.getConnection()) {
            String sql = getSql(createTableSQL);
            try (PreparedStatement stmt = connection.prepareStatement(sql)) {
                stmt.executeUpdate();
            }
        } catch (SQLException e) {
            Log.log().log(Level.SEVERE, e,
                    () -> String.format("Unable to check or create the database [clazz=%s]", clazz));
        }
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    private void addTableToFinder(Class<? extends Row> classRow, Class<? extends Table> clazz) {
        Table<Row> table;
        try {
            table = clazz.getDeclaredConstructor().newInstance();
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
                 | NoSuchMethodException | SecurityException e) {
            Log.log().log(Level.SEVERE, e,
                    () -> String.format("Unable create Table instance due to a programming error [clazz=%s]", clazz));
            return;
        }

        classRowToTable.put(classRow, table);
    }

    String getSql(String sqlFormat) {
        String tablePrefix = config().databasePrefix();
        if (getDbDriver().equals(ConnectionManager.DRIVER_MARIADB)) {
            return String.format(sqlFormat, tablePrefix)
                    .replace(AUTOINCREMENT_TAG, AUTOINCREMENT_MARIADB)
                    .replace(TINYTEXT_TAG, TINYTEXT_MARIADB)
                    .replace(TEXT_TAG, TEXT_MARIADB)
                    .replace(MEDIUMTEXT_TAG, MEDIUMTEXT_MARIADB)
                    .concat(MARIADB_CREATE_SQL_SUFFIX);
        }
        return String.format(sqlFormat, tablePrefix)
                .replace(AUTOINCREMENT_TAG, AUTOINCREMENT_HSQLDB)
                .replace(TINYTEXT_TAG, TINYTEXT_HSQLDB)
                .replace(TEXT_TAG, TEXT_HSQLDB)
                .replace(MEDIUMTEXT_TAG, MEDIUMTEXT_HSQLDB);
    }

    String getDbDriver() {
        return config().databaseDriver();
    }
}
